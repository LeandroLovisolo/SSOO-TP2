\documentclass[a4paper,10pt,twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-ucroman,es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}
\usepackage{algpseudocode}
\usepackage{enumitem} % Provee macro \setlist
\usepackage[toc, page]{appendix}


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Trabajo Práctico 2 · Sistemas Operativos}
\rhead{Delgado · Lovisolo · Petaccio}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Configuración de Algorithmic - Inicio %%%%%%%%%%
% Entorno propio para customizar la presentación del pseudocódigo
\newenvironment{pseudo}[1][]{%
    \vspace{0.5em}%
    \begin{algorithmic}%
}
{%
    \end{algorithmic}%
    \vspace{0.5em}%
}

% Llamada a función para usar así: \Fn{Foo}{bar, baz}.
% Produce \textsc{Foo}$(bar, baz)$.
\newcommand{\Fn}[2]{\textsc{#1}$(#2)$}

% Cláusula return para usar así: \PReturn foo
\newcommand{\PReturn}[1]{\textbf{return} $#1$}

% Cláusula break
\newcommand{\Break}{\textbf{break}}

% Operadores lógicos
\newcommand{\PAnd}{\textbf{and} }
\newcommand{\POr}{\textbf{or} }
\newcommand{\PNot}{\textbf{not} }

% Booleanos
\newcommand{\PTrue}{\textnormal{TRUE} }
\newcommand{\PFalse}{\textnormal{FALSE} }

% Null
\newcommand{\Null}{\textnormal{NULL} }

% Conectivo 'in' para usar así: \ForAll{$foo$ \In $bar$}
\newcommand{\In}{\textbf{in} }

% Conectivo 'to' para usar así: \For{$i = 1$ \In $n$}
\newcommand{\To}{\textbf{to} }

% Complejidades
\newcommand{\Ode}[1]{\hfill $O(#1)$}
%%%%%%%%%% Configuración de Algorithmic - Fin %%%%%%%%%%


%%%%%%%%%% Configuración de Appendix - Inicio %%%%%%%%%%
% Asigna la traducción de la palabra 'Appendices'.
\renewcommand{\appendixtocname}{Apéndices}
\renewcommand{\appendixpagename}{Apéndices}
%%%%%%%%%% Configuración de Appendix - Fin %%%%%%%%%%


%%%%%%%%%% Miscelánea - Inicio %%%%%%%%%%
% Evita que el documento se estire verticalmente para ocupar el espacio vacío
% en cada página.
\raggedbottom

% Deshabilita sangría en la primer línea de un párrafo.
\setlength{\parindent}{0em}

% Separación entre párrafos.
\setlength{\parskip}{0.5em}

% Separación entre elementos de listas.
\setlist{itemsep=0.5em}
%%%%%%%%%% Miscelánea - Fin %%%%%%%%%%


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
Trabajo Práctico 2
\end{Huge}

\vspace{0.5cm}

\begin{Large}
Sistemas Operativos
\end{Large}

\vspace{1cm}

Segundo Cuatrimestre de 2013

\vspace{4cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Alejandro Nahuel Delgado & 601/11 & nahueldelgado@gmail.com\\
Leandro Lovisolo         & 645/11 & leandro@leandro.me\\
Lautaro José Petaccio    & 443/11 & lausuper@gmail.com\\
\hline
\end{tabular}

\end{center}

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Índice                                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Readers-Writers Lock                                                      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Readers-Writers Lock}

Tomamos la implementación del readers-writers lock libre de inanición de escritura presentada en el libro \textit{The Little Book of Semaphores}, versión 2.1.5, por Allen B. Downey.

Este libro utiliza la analogía de una habitación en la que pueden haber o varios lectores a la vez y ningún escritor, o un único escritor por vez y ningún lector; y un interruptor que prende o apaga la luz de la habitación para señalar si ésta está ocupada o no.

Durante la creación del lock se inicializan las siguientes variables:

\begin{pseudo}
    \State $readers \leftarrow 0$ \Comment{Cantidad de \textbf{lectores} actualmente en la habitación.}
    \State $turnstile \leftarrow$ \Fn{Semaphore}{1} \Comment{Molinete que deja pasar lectores de a uno por vez.}
    \State $room\_empty \leftarrow$ \Fn{Semaphore}{1} \Comment{Vale 1 si la habitación está vacía, o 0 en caso contrario.}
    \State $readers\_mutex \leftarrow$ \Fn{Semaphore}{1} \Comment{Mutex para acceder a la variable $readers$.}
\end{pseudo}

Las operaciones del lock quedan definidas como a continuación.

\begin{pseudo}
    \Procedure{Read-Lock}{}
        \State \Fn{Wait}{turnstile} \Comment{Paso por el molinete, un lector a la vez.}
        \State \Fn{Signal}{turnstile}
        \State
        \State \Fn{Wait}{readers\_mutex}
        \State $readers \leftarrow readers + 1$ \Comment{Aumento en 1 la cantidad de lectores.}
        \If{readers = 1} \Comment{¿Soy el primer lector en llegar?}
            \State \Fn{Wait}{room\_empty} \Comment{Espero a que se vacíe la habitación, luego entro y prendo al luz.}
        \EndIf
        \State \Fn{Signal}{readers\_mutex}
    \EndProcedure
\end{pseudo}

\begin{pseudo}
    \Procedure{Read-Unlock}{}
        \State \Fn{Wait}{readers\_mutex}
        \State $readers \leftarrow readers - 1$ \Comment{Decremento en 1 la cantidad de lectores.}
        \If{readers = 0} \Comment{¿Soy el último lector en irse?}
            \State \Fn{Signal}{room\_empty} \Comment{Apago la luz al salir.}
        \EndIf
        \State \Fn{Signal}{readers\_mutex}
    \EndProcedure
\end{pseudo}

\begin{pseudo}
    \Procedure{Write-Lock}{}
        \State \Fn{Wait}{turnstile} \Comment{Bloqueo el molinete para que no ingresen nuevos lectores.}
        \State \Fn{Wait}{room\_empty} \Comment{Espero a que se vacíe la habitación; luego entro y prendo la luz.}
    \EndProcedure
\end{pseudo}

\begin{pseudo}
    \Procedure{Write-Unlock}{}
        \State \Fn{Signal}{turnstile} \Comment{Permito el ingreso a lectores.}
        \State \Fn{Signal}{room\_empty} \Comment{Apago la luz al salir (señalo que la habitación está vacía.)}
    \EndProcedure
\end{pseudo}

Cuando llega un lector (\Fn{Read-Lock}{}), éste pasa exitosamente por el molinete (\Fn{Wait}{turnstile}) pues el semáforo $turnstile$ vale inicialmente 1 y restaura el valor original del semáforo (\Fn{Signal}{turnstile}) para que subsiguientes lectores puedan ingresar. Luego incrementa en 1 la cantidad de lectores, y si resulta que es el primer lector en ingresar, espera que se vacíe la habitación en caso de estar ocupada por algún escritor (\Fn{Wait}{room\_empty}) y prende la luz al entrar ($room\_empty$ vale 0 luego del \textsc{Wait}.)

Al retirarse (\Fn{Read-Unlock}{}), el lector decrementa en 1 la cantidad de lectores, y en caso de ser el último, apaga la luz al salir (\Fn{Signal}{room\_empty}.)

Cuando llega un escritor (\Fn{Write-Lock}{}), éste bloquea el molinete para que no ingresen nuevos lectores (\Fn{Wait}{turnstile}) y en caso de que haya algún lector en la habitación, espera hasta que se retire el último lector (\Fn{Wait}{room\_empty}) y prende la luz al entrar ($room\_empty$ vale 0 luego del \textsc{Wait}.) Al bloquear el ingreso a nuevos lectores \textbf{nos aseguramos que no ocurra inanición de escritura}, pues de lo contrario podría darse el caso de tener un número muy grande de lectores ingresando constantemente a la habitación, haciendo que ésta nunca quede vacía.

Finalmente, al retirarse un escritor (\Fn{Read-Unlock}{}), éste desbloquea el molinete para permitir el paso a los lectores (\Fn{Signal}{turnstile}) y apaga la luz al salir (\Fn{Signal}{room\_empty}). 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Modelo                                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Modelo}

A continuación listamos el conjunto de campos de la clase \textsc{Modelo} que protegemos mediante read-write locks, junto con sus respectivos locks.

\begin{itemize}
    \item{$cantidad\_jugadores$: $lock\_cantidad\_jugadores$.}
    \item{$jugadores\_listos$: $lock\_jugadores\_listos$.}
    \item{$jugadores[]$: $locks\_jugadores[]$.}
    \item{$eventos[]$: $locks\_eventos[]$.}
    \item{$jugando$: $lock\_jugando$.}    
\end{itemize}


\subsection{Modelo::agregarJugador}

\begin{pseudo}
    \Procedure{Modelo::agregarJugador}{$nombre$}
        \State
        \State Protegemos $jugando$ con un read lock para evitar que comience el juego mientras estamos agregando al nuevo jugador.
        \State
        \State \Fn{rlock}{lock\_jugando}
        \If{$jugando \neq$ \texttt{SETUP}}
            \State \Fn{runlock}{lock\_jugando}
            \State \PReturn{-\texttt{ERROR\_JUEGO\_EN\_PROGRESO}}
        \EndIf
        \State  
        \State $nuevoid \leftarrow$ 0
        \State $agregado \leftarrow$ \PFalse
        \For{$nuevoid \leftarrow$ 0 \To $max\_jugadores$ - 1}
            \State
            \State Protegemos el jugador $nuevoid$ con un write lock para evitar que al agregarse otro jugador en simultáneo, éste no utilice el mismo id.
            \State
            \State \Fn{wlock}{locks\_jugadores[nuevoid]}
            \If{$jugadores[nuevoid] =$ \Null}
                \State $jugadores[nuevoid] \leftarrow$ \Fn{jugador}{nombre}
                \State \Fn{wunlock}{locks\_jugadores[nuevoid]}
                \State agregado $\leftarrow$ \PTrue
                \State \Break
            \EndIf
            \State \Fn{wunlock}{locks\_jugadores[nuevoid]}
        \EndFor
         \If{\PNot $agregado$}
            \State \Fn{runlock}{lock\_jugando}
            \State \PReturn{- \texttt{ERROR\_MAX\_JUGADORES}}
        \EndIf
        \State
        \State Protegemos la variable cantidad\_jugadores con un write lock contra otros incrementos por nuevos jugadores que se agregan
        y para asegurar la lectura correcta de la variable al ubicar barcos.
        \State
        \State \Fn{wlock}{lock\_cantidad\_jugadores}
        \State $cantidad\_jugadores \leftarrow cantidad\_jugadores + 1$
        \State \Fn{wunlock}{lock\_cantidad\_jugadores}
        \State
        \State \Fn{runlock}{lock\_jugando}
        \State \PReturn{nuevoid}
    \EndProcedure
\end{pseudo}


\subsection{Modelo::ubicar}

\begin{pseudo}
    \Procedure{Modelo::ubicar}{$t\_id, xs, ys, tamanio$}
        \State
        \State Protegemos $jugando$ con un read lock para evitar que comience el juego mientras estamos ubicando un barco.
        \State
        \State \Fn{wlock}{lock\_jugando}
        \If{jugando $\neq$ \texttt{SETUP}}
            \State \Fn{wunlock}{lock\_jugando}
            \State \PReturn{- \texttt{ERROR\_JUEGO\_EN\_PROGRESO}}
        \EndIf
        \State
        \State Protegemos el jugador contra lecturas y escrituras simultáneas.
        \State
        \State \Fn{wlock}{locks\_jugadores[t\_id]}
        \If{jugadores[t\_id] = \Null}
            \State \Fn{wunlock}{locks\_jugadores[t\_id]}
            \State \Fn{wunlock}{lock\_jugando}
            \State \PReturn{- \texttt{ERROR\_JUGADOR\_INEXISTENTE}}
        \EndIf
        \State
        \State $retorno \leftarrow jugadores[t\_id].$\Fn{ubicar}{xs, ys, tamanio}
        \State
        \If{$retorno \neq$ \texttt{ERROR\_NO\_ERROR}}
            \State \Fn{borrar\_barcos}{t\_id}
        \EndIf
        \State
        \If{$retorno = $ \texttt{ERROR\_NO\_ERROR} \PAnd $jugadores[t\_id].$\Fn{listo}{}} \Comment{Si el jugador está listo}
            \State \Fn{wlock}{lock\_jugadores\_listos}
            \State $jugadores\_listos \leftarrow jugadores\_listos + 1$
            \State
            \If{$jugadores\_listos = max\_jugadores$} \Comment{Si ya están listos todos los jugadores}
                \State \Fn{\_empezar}{}
            \EndIf
            \State \Fn{wunlock}{lock\_jugadores\_listos}
        \EndIf
        \State
        \State \Fn{wunlock}{locks\_jugadores[t\_id]}
        \State \Fn{wunlock}{locks\_jugando}
        \State \PReturn{retorno}
    \EndProcedure
\end{pseudo}


\subsection{Modelo::empezar}

Separamos este método en dos partes: \textsc{Modelo::empezar}, que toma write lock sobre $jugando$ y llama a \textsc{Modelo::\_empezar}, que asume que ya se tiene el write lock sobre $jugando$ y realiza la operación de empezar. El método \textsc{Modelo::empezar} se llama desde la clase \textsc{Decodificador}, que no tiene acceso a dicho lock directamente, mientras que \textsc{Modelo::\_empezar} se llama desde \textsc{Modelo::ubicar}, que ya toma lock de escritura sobre $jugando$ para proteger operaciones anteriores a \textsc{Modelo::\_empezar}.

Si no se abriera este método en los dos casos mencionados, tendríamos un único método que toma write lock sobre $jugando$, pues como \textsc{Decodificador} no tiene acceso a ese lock, no queda otra opción. Entonces \textsc{Modelo::ubicar} produciría dos llamadas consecutivas \Fn{wlock}{lock\_jugando}, generando así un deadlock. Separando este método en dos casos distintos evitamos el deadlock.

\begin{pseudo}
    \Procedure{Modelo::empezar}{}
        \State \Fn{wlock}{lock\_jugando}
        \State $out \leftarrow$ \Fn{\_empezar}{}
        \State \Fn{wunlock}{lock\_jugando}
        \State \PReturn{out}
    \EndProcedure
\end{pseudo}

\begin{pseudo}
    \Procedure{Modelo::\_empezar}{}
    	\If{$jugando \neq$ \texttt{SETUP}}
    		\State \PReturn{-\texttt{ERROR\_JUEGO\_EN\_PROGRESO}}
    	\EndIf
    	\For{$i \leftarrow 0$ \To $max\_jugadores - 1$}
    		\If{$jugadores[i] \neq$ \Null}
    			\State $evento \leftarrow$ \Fn{evento}{0, i, 0, 0, \texttt{EVENTO\_START}}
                \State
                \State Tomamos write lock de la cola de eventos del jugador para evitar que ésta se lea desde el ciclo principal de su thread en server.cpp mientras agregamos el nuevo evento.
                \State
    			\State \Fn{wlock}{locks\_eventos[i]}
    			\State $eventos[i].$\Fn{push}{evento}
    			\State \Fn{wunlock}{locks\_eventos[i]}
    		\EndIf
    	\EndFor
    	\State $jugando \leftarrow$ \texttt{DISPAROS}
    	\State \PReturn{\texttt{ERROR\_NO\_ERROR}}
    \EndProcedure
\end{pseudo}


\subsection{Modelo::finalizar}

\begin{pseudo}
    \Procedure{modelo::finalizar}{}
    	\If{$jugando \neq$ \texttt{DISPAROS}}
            \State \PReturn{-\texttt{ERROR\_JUEGO\_NO\_COMENZADO}}
        \EndIf
    	\For{$i \leftarrow 0$ \To $max\_jugadores - 1$}
    		\If{$jugadores[i] \neq$ \Null}
    			\State $evento  \leftarrow$ \Fn{evento}{0, i, 0, 0, \texttt{EVENTO\_START}}
                \State
                \State Tomamos write lock de la cola de eventos del jugador para evitar que ésta se lea desde el ciclo principal de su thread en server.cpp mientras agregamos el nuevo evento.
                \State
    			\State \Fn{wlock}{locks\_eventos[i]}
    			\State $eventos[i].$\Fn{push}{evento}
    			\State \Fn{wunlock}{locks\_eventos[i]}
    		\EndIf
    	\EndFor
    	\State $jugando \leftarrow$ \texttt{FINALIZADO}
    	\State \PReturn{\texttt{ERROR\_NO\_ERROR}}
    \EndProcedure
\end{pseudo}


\subsection{Modelo::ack}

\begin{pseudo}
    \Procedure{modelo::ack}{}
        \State
        \State Tomamos write lock para evitar lecturas mientras registramos el ack.
        \State
    	\State \Fn{wlock}{locks\_jugadores[s_id]}
    	\State $retorno \leftarrow$ jugadores[s\_id].\Fn{ack}{}
    	\State \Fn{wunlock}{locks\_jugadores[s\_id]}
    	\State \PReturn{retorno}
    \EndProcedure
\end{pseudo}


\subsection{Modelo::termino}

\begin{pseudo}
    \Procedure{termino}{}
    	\State \Fn{rlock}{lock\_jugando}
    	\If{$jugando$ = \texttt{SETUP}}
    		\State \Fn{runlock}{lock\_jugando}
    		\State \PReturn{\PFalse}
    	\EndIf
    	\State \Fn{runlock}{lock\_jugando}
        \State
        \For{$i \leftarrow 0$ \To $max\_jugadores$ - 1}
            \State
            \State Tomamos read lock para proteger de una posible escritura en cada jugador desde \textsc{Modelo::ack}.
            \State
        	\State \Fn{rlock}{locks\_jugadores[i]}
            \If{\PNot $jugadores[i].$\Fn{termino}{}}
            	\State \Fn{runlock}{locks\_jugadores[i]}
                \State \PReturn{\PFalse}
            \EndIf
            \State \Fn{runlock}{locks\_jugadores[i]}
        \EndFor
        \State \PReturn{\PTrue}
    \EndProcedure
\end{pseudo}


\subsection{Modelo::quitarJugador}

\begin{pseudo}
    \Procedure{Modelo::quitarJugador}{$s\_id$}
        \State
        \State Tomamos lock de lectura para evitar que se transicione hacia la fase \texttt{DISPAROS} mientras quitamos al jugador $s\_id$.
        \State
    	\State \Fn{rlock}{lock\_jugando}
    	\If{$jugando \neq$ \texttt{SETUP}}
    		\State \Fn{runlock}{lock\_jugando}
    		\State \PReturn{-\texttt{ERROR\_JUEGO\_EN\_PROGRESO}}
    	\EndIf
        \State
        \State Tomamos lock de escritura para evitar accesos a memoria inválidos mientras liberamos la memoria ocupada por los datos del jugador.
        \State
    	\State \Fn{wlock}{locks\_jugadores[s\_id]}
    	\If{$jugadores[s\_id]$ = \Null}
    		\State \Fn{wunlock}{locks\_jugadores[s\_id]}
    		\State \Fn{runlock}{lock\_jugando}
    		\State \PReturn{-\texttt{ERROR\_JUGADOR\_INEXISTENTE}}
    	\EndIf
        \State
    	\State \Fn{delete}{jugadores[s\_id]}
        \State $jugadores[s\_id] \leftarrow$ \Null
        \State
    	\State \Fn{wunlock}{locks\_jugadores[s\_id]}
    	\State \Fn{runlock}{lock\_jugando}
    	\State \PReturn{\texttt{ERROR\_NO\_ERROR}}
    \EndProcedure
\end{pseudo}


\subsection{Modelo::apuntar}

\begin{pseudo}
    \Procedure{apuntar}{$s\_id, t\_id, x, y, *eta$}
        \State
        \State Tomamos read lock sobre $jugando$ para evitar que termine el juego mientars estamos apuntando.
        \State
        \State \Fn{rlock}{lock\_jugando}
        \If{$jugando \neq$ \texttt{DISPAROS}}
            \State \Fn{runlock}{lock\_jugando}
            \State \PReturn{-\texttt{ERROR\_JUEGO\_NO\_COMENZADO}}
        \EndIf
        \State
        \State Tomamos lock de escritura sobre ambos jugadores para realizar el tiro. Esto evita que se escriba el mismo jugador por más de un thread en el caso de tener dos jugadores apuntando al mismo jugador a la vez.
        \State
        \State \Fn{wlock}{locks\_jugadores[s\_id]}
        \State \Fn{wlock}{locks\_jugadores[t\_id]}
        \State
        \If{$jugadores[s\_id] = $ \Null \POr $jugadores[t\_id] = $ \Null}
            \State \Fn{runlock}{lock\_jugando}
            \State \Fn{wunlock}{locks\_jugadores[s\_id]}
            \State \Fn{wunlock}{locks\_jugadores[t\_id]}            
            \State \PReturn{-\texttt{ERROR\_JUGADOR\_INEXISTENTE}}
        \EndIf
        \State
        \If{$jugadores[s\_id].$\Fn{esta\_vivo}{}}
            \State \Fn{runlock}{lock\_jugando}
            \State \Fn{wunlock}{locks\_jugadores[s\_id]}
            \State \Fn{wunlock}{locks\_jugadores[t\_id]}            
            \State \PReturn{-\texttt{ERROR\_JUGADOR\_HUNDIDO}}        
        \EndIf
        \State
        \State $retorno \leftarrow$ \texttt{RESULTADO\_APUNTADO\_DENEGADO}
        \State
        \If{$tiros[s\_id].$\Fn{es\_posible\_apuntar}{}}
            \State $retorno \leftarrow jugadores[t\_id].$\Fn{apuntar}{s\_id, x, y}
            \If{$retorno = $ \texttt{RESULTADO\_APUNTADO\_ACEPTADO}}
                \State $*eta \leftarrow tiros[s\_id].$\Fn{tirar}{t\_id, x, y}
                \State $nuevoevento \leftarrow $ \Fn{evento}{s\_id, t\_id, x, y, \texttt{CASILLA\_EVENTO\_INCOMING}}
                \State
                \State \Fn{wlock}{locks\_eventos[t\_id]}
                \State $eventos[t\_id].$\Fn{push}{nuevoevento}
                \State \Fn{wunlock}{locks\_eventos[t\_id]}
            \EndIf
        \EndIf
        \State
        \State \Fn{wunlock}{locks\_jugadores[s\_id]}
        \State \Fn{wunlock}{locks\_jugadores[t\_id]}
        \State \Fn{runlock}{lock\_jugando}
        \State \PReturn{retorno}
    \EndProcedure
\end{pseudo}


\subsection{Modelo::tocar}

\begin{pseudo}
    \Procedure{tocar}{$s\_id, t\_id$}
        \State
        \State Tomamos read lock sobre $jugando$ para evitar que termine el juego mientars registramos el toque.
        \State
        \State \Fn{wlock}{lock\_jugando}
        \If{$jugando \neq $ \texttt{DISPAROS}}
            \State \Fn{wunlock}{lock\_jugando}
            \State \PReturn{- \texttt{ERROR\_JUEGO\_NO\_COMENZADO}}
        \EndIf
        \State
        \If{$jugadores[s\_id] =$ \Null \POr $jugadores[t\_id] = $ \Null}
            \State \Fn{wunlock}{lock\_jugando}
            \State \PReturn{- \texttt{ERROR\_JUGADOR\_INEXISTENTE}}
        \EndIf
        \State
        \State $retorno \leftarrow$ -\texttt{ERROR\_ETA\_NO\_TRANSCURRIDO}
        \State
        \If{$tiros[s\_id].$\Fn{es\_posible\_tocar}{}}
            \State
            \State Tomamos locks de escritura sobre ambos jugadores para poder tener acceso de forma exclusiva mientras actualizamos los puntajes.
            \State
            \State \Fn{wlock}{locks\_jugadores[t\_id]}
            \State \Fn{wlock}{locks\_jugadores[s\_id]}
            \State
            \State $x \leftarrow tiros[s\_id].x$
            \State $y \leftarrow tiros[s\_id].y$
            \State $retorno, murio \leftarrow jugadores[t\_id].$\Fn{tocar}{s\_id, x, y} \Comment{Devuelve un código de error y un}
            \State \hfill booleano que indica si murió o no.
            \State
            \If{$retorno = $ \texttt{EMBARCACION\_RESULTADO\_TOCADO} \POr \\
                \hspace{3.8em} $retorno = $ \texttt{EMBARCACION\_RESULTADO\_HUNDIDO} \POr \\
                \hspace{3.8em} $retorno = $ \texttt{EMBARCACION\_RESULTADO\_HUNDIDO\_M} \POr \\
                \hspace{3.8em} $retorno = $ \texttt{EMBARCACION\_RESULTADO\_AGUA} \POr \\
                \hspace{3.8em} $retorno = $ \texttt{EMBARCACION\_RESULTADO\_AGUA\_H}}
                \State
                \State $tiros[s\_id].estado \leftarrow$ \texttt{TIRO\_LIBRE}
                \State $evento \leftarrow$ \Fn{evento}{s\_id, t\_id, x, y, retorno}
                \State
                \State \Fn{wlock}{locks\_eventos[t\_id]} \Comment{Evento para el tirado}
                \State $eventos[t\_id].$\Fn{push}{evento}
                \State \Fn{wunlock}{locks\_eventos[t\_id]}
                \State
                \State \Fn{wlock}{locks\_eventos[s\_id]} \Comment{Evento para el tirador}
                \State $eventos[s\_id].$\Fn{push}{evento}
                \State \Fn{wunlock}{locks\_eventos[s\_id]}
                \State
                \If{$murio$}
                    \State 
                    \State Tomamos el lock de la variable lock\_cantidad\_jugadores para asegurar su correcta escritura en caso de que dos jugadores pierdan sus barcos al mismo tiempo.
                    \State 
                    \State \Fn{wlock}{lock\_cantidad\_jugadores}
                    \State $cantidad\_jugadores \leftarrow cantidad\_jugadores - 1$
                    \If{$cantidad\_jugadores = 1$}
                        \State \Fn{finalizar}{}
                    \EndIf
                    \State \Fn{wunlock}{lock\_cantidad\_jugadores}
                \EndIf
            \EndIf
            \If{$retorno =$ \texttt{EMBARCACION\_RESULTADO\_HUNDIDO}}
                \State $jugadores[s\_id].$\Fn{agregar\_puntaje}{\texttt{PUNTAJE\_HUNDIDO}}
            \ElsIf{$retorno =$ \texttt{EMBARCACION\_RESULTADO\_HUNDIDO\_M}}
                \State $jugadores[s\_id].$\Fn{agregar\_puntaje}{\texttt{PUNTAJE\_HUNDIDO} + \texttt{PUNTAJE\_MISMO\_JUGADOR}}
            \ElsIf{$retorno =$ \texttt{EMBARCACION\_RESULTADO\_TOCADO}}
                \State $jugadores[s\_id].$\Fn{agregar\_puntaje}{\texttt{PUNTAJE\_TOCADO}}
            \ElsIf{$retorno =$ \texttt{EMBARCACION\_RESULTADO\_AGUA\_H}}
                \State $jugadores[s\_id].$\Fn{agregar\_puntaje}{\texttt{PUNTAJE\_MAGALLANES}}
            \EndIf
            \State
            \State \Fn{wunlock}{locks\_jugadores[t\_id]}
            \State \Fn{wunlock}{locks\_jugadores[s\_id]}
        \EndIf
        \State
        \State \Fn{wunlock}{lock\_jugando}
        \State
        \State \PReturn{retorno}
    \EndProcedure
\end{pseudo}


\subsection{Modelo::hayEventos}
Tomamos lock de lectura para la cola de eventos del jugador para evitar que cambie el tamaño de esta.
\begin{pseudo}
    \Procedure{hayEventos}{$s\_id$}
        \State \Fn{rlock}{locks\_eventos[s\_id]}
        \State $eventos \leftarrow eventos[s\_id]$.\Fn{size}{} $> 0$
        \State \Fn{runlock}{locks\_eventos[s\_id]}
        \State \PReturn{eventos}
    \EndProcedure
\end{pseudo}


\subsection{Modelo::dameEvento}
Tomamos lock de escritura sobre la cola de eventos del jugador para evitar lecturas por parte del
ciclo principal de su thread en server.cpp y escrituras por parte de funciones como apuntar y tocar
mientras se remueve un evento de la cola.
\begin{pseudo}
    \Procedure{dameEvento}{$s\_id$}
        \State \Fn{wlock}{locks\_eventos[s\_id]}
        \State $retorno \leftarrow eventos[s\_id]$.\Fn{front}{}
        \State $eventos[s_id]$.\Fn{pop}{}
        \State \Fn{wunlock}{locks\_eventos[s\_id]}
        \State \PReturn{retorno}
    \EndProcedure
\end{pseudo}


\subsection{Modelo::actualizar\_jugador}
Tomamos un lock de escritura sobre los eventos del jugador para protegerla contra escrituras o lecturas
mientras se remueve un elemento de la cola. 
\begin{pseudo}
    \Procedure{actualizar\_jugador}{$s\_id$}
        \State $tocado \leftarrow$ \Fn{tocar}{s\_id, tiros[s\_id].t\_id}
        \State \Fn{wlock}{locks\_eventos[s\_id]}
        \If{$eventos[s\_id]$.\Fn{size}{} $> 0$}
            \State $retorno \leftarrow eventos[s\_id]$.\Fn{front}{}
            \State $eventos[s\_id]$.\Fn{pop}{}
            \State \Fn{wunlock}{locks\_eventos[s\_id]}
            \State \PReturn{retorno}
        \Else
            \State $retorno \leftarrow$ \Fn{evento}{s\_id, -1, 0, 0, -tocado}
            \State \Fn{wunlock}{locks\_eventos[s\_id]}
            \State \PReturn{retorno}
        \EndIf
    \EndProcedure
\end{pseudo}


\subsection{Modelo::printPuntajes}
Esta función no aporta funcionalidad a la sincronización, pero fue agregada a la clase para poder imprimir los puntajes de los jugadores al finalizar la partida.
\begin{pseudo}
    \Procedure{printPuntaje}{}
        \For{$i \leftarrow$ 0 \To $jugadores\_listos$ - 1}
            \State \Fn{printf}{$"Nombre: \%s - Puntaje: \%d"$, jugadores[i].\Fn{dame\_nombre}{}.\Fn{c\_str}{}, jugadores[i].\Fn{dame\_puntaje}{}}
        \EndFor
    \EndProcedure
\end{pseudo}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Server                                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Server}

A continuación documentaremos las modificaciones hechas al servidor.

\begin{itemize}
    \item Se crea la función abrir\_socket\_controladores() que crea el socket correspondiente para la escucha de nuevos controladores
    
    \item Se crea la función controlador() para atender las comunicaciones entre un controlador y el servidor. El código de ésta función difiere del código del servidor monothread en tanto que en lugar de invocarse a atender\_controlador() mientras que el juego no haya terminado, se invoca de forma indeterminada para permitirles a los controladores realizar consultas aún después que el juego haya terminado.
    
    \item Se crea la función aceptar\_controladores() que es llamada en un nuevo thread para atender las nuevas conexiones de hasta un máximo de MAX\_CONTROLADORES controladores. Esta función crea un nuevo thread llamando a la función controlador() para atender a cada controlador de manera simultánea.

    Aceptar\_controladores  se llama en un nuevo thread para asegurar la disponibilidad de controladores durante todo momento en el juego.
    
    \item Se crea la función abrir\_socket\_jugadores() que crea el socket correspondiente para la escucha de nuevos jugadores con el sentido de tener una mejor modularización del código.
    
    \item Se crea la función jugador() la cual atenderá los mensajes de los jugadores con el servidor hasta que el juego haya terminado.
    
    \item Se modifica acceptar\_jugadores() para que al conectarse un nuevo jugador, se cree un nuevo thread llamando a la función jugador() con el objetivo de atender jugadores de manera simultanea.
    
    \item Una vez aceptados todos los jugadores, se utiliza pthread\_join() para realizar la espera de los threads relacionados a los jugadores ya que es necesario esperar hasta que terminen las comunicaciones para cerrar el servidor.
    
    \item Una vez que joinearon todos los threads de jugadores, se cierra el socket de controladores para evitar conexiones de nuevos controladores, y se espera que los threads de controladores terminen de ejecutarse por medio de pthread\_join().

    \item Finalmente, el servidor cierra los sockets utilizados tanto para atender nuevas conexiones de controladores y jugadores, como para realizar la comunicación entre ellos y el servidor.
\end{itemize}

Prsentamos el pseudocódigo de jugador() y controlador()

\begin{pseudo}
    \Procedure{jugador}{$*nro\_jugador\_ptr$}
        \State $nro\_jugador \leftarrow$ $*nro\_jugador\_ptr$
        \State \Fn{delete}{nro\_jugador\_ptr}
        \State $sale \leftarrow$ \PFalse
        \State
        \State Mientras que no termine el juego, atiendo los pedidos de los jugadores
        \State
        \While{\PNot $sale$}
            \State \Fn{atender\_jugador}{nro\_jugador}
            \State $sale \leftarrow model.$\Fn{termino}{}
        \EndWhile
        \State \PReturn{0}
    \EndProcedure
\end{pseudo}

\begin{pseudo}
    \Procedure{controlador}{$*nro\_controlador\_ptr$}
        \State $nro\_controlador \leftarrow *nro\_controlador\_ptr$
        \State \Fn{delete}{nro\_controlador\_ptr}
        \State $sale \leftarrow$ \PFalse
        \While{\PTrue}
            \State \Fn{atender\_controlador}{nro\_controlador}
        \EndWhile
        \State \PReturn{0}
    \EndProcedure
\end{pseudo}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Jsonificador                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Jsonificador}


\subsection{Jsonificador::start}

Utilizamos un read lock para que otras operaciones sobre los jugadores no modifiquen al jugador del que estoy
leyendo su información.

\begin{pseudo}
    \For{$i \leftarrow 0$ \To $max\_jugadores$}
       \State \Fn{rlock}{modelo.locks\_jugadores[i]}
       \State Lectura de datos del jugador
       \State \Fn{runlock}{modelo.locks\_jugadores[i]}

    \EndFor
\end{pseudo}

\subsection{Jsonificador::player\_info}

Utilizamos un read lock para que ninguna otra operación escriba mientras leemos los datos del jugador.

\begin{pseudo}
    \State \Fn{rlock}{modelo.locks\_jugadores[id]}
    \State Lectura de datos del jugador
    \State \Fn{runlock}{modelo.locks\_jugadores[id]}
\end{pseudo}


\subsection{Jsonificador::scores}

Protegemos con un read lock al jugador a leer para que ninguna otra operación escriba
sobre éste mientras obtenemos información de este.

\begin{pseudo}
    \For{$i \leftarrow 0$ \To $max\_jugadores$}
       \State \Fn{rlock}{modelo.locks\_jugadores[i]}
       \State Utilización de datos del jugador
       \State \Fn{runlock}{modelo.locks\_jugadores[i]}
    \EndFor
\end{pseudo}
\end{document}